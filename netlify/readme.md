# Learning Netlify essentials
## Understanding serverless
Building and deploying web application has been based on HTTP requests sent to server. The application runs on server and developers have had to cover certain tasks to maintain the server. For example,

- Keeping the server up
- Responsible for uptime(a time that is in operation)
- Server security

and so on. And the need to minimize and address them more effiecently has been growing fast. This is where serverless concept comes into a play. 

## Serverless computing
Basically, serverless means that cloud provider will execute code and allocate resources. And this is done based on the only amount of resources needed to run the codes. 

The codes run on, mostly, inside stateless container dealing with many events such as HTTP requests, database, file upload, and so on. Cloud provider takes the codes in the format of function - that is why it is sometimes called a Functions as a Service(FaaS). Types of FaaS providers are as follows :  

- AWS : AWS lambda
- Microsoft Azure : Azure Functions
- Google Cloud : Cloud Functions

## Basics
> With Netlify Functions, your serverless functions are version-controlled, built, and deployed along with the rest of your Netlify site, and we will automatically handle service discovery through our built-in API gateway. This eliminates overhead and brings the power of Deploy Previews and rollbacks to your functions.

> Currently, you can deploy functions built with JavaScript, TypeScript, and Go.

> Functions deployed from Netlify are immutable. This means that an update to a function on your production branch won’t change the version that was deployed in a branch deploy, or in a Deploy Preview. You can access all versions of your functions in the Netlify web interface, under the Functions tab.

Default Netlify functions options are as follows : 

1. us-east-1 AWS Lambda region
1. 1024MB of memory
1. 10 second execution limit for synchronous functions
1. 15 minute execution limit for background functions

Recommended base directory for Netlify functions is as follows : 

```
my-base-directory/
├─ package.json
├─ node_modules
└─ my-functions/
   ├─ hello.js
   └─ send-pdf-background.js
```

### Background functions
> Netlify’s Background Functions allow you to set up serverless function processes that run longer than 10 seconds and up to 15 minutes. For tasks like batch processing, scraping, and slower API workflow execution, they may be a better fit than synchronous functions.

> These longer-running functions are processed as background tasks using asynchronous invocation. When a function is invoked asynchronously, there is an initial 202 success response. If function execution returns an error, an execution retry happens after one minute. If it fails again, another retry happens two minutes later. When a background function is successfully executed, you generally pass the result to a destination other than the originating client.

### Configure and deploy
> To get started, designate a directory in your repository where Netlify can find your function sources, including background functions. Netlify will access this directory during every deploy, zipping and deploying each supported code file as a function.

> If you choose not to designate a directory, Netlify will deploy functions you save in YOUR_BASE_DIRECTORY/netlify/functions.

#### Netlify.toml
> The netlify.toml is a configuration file that specifies how Netlify builds and deploys your site — including redirects, branch and context-specific settings, and more. Its goal is to describe much of your site configuration alongside your code

> The file is normally stored in the root of your site repository.

```toml
[functions]
  directory = "my_functions"

# Settings in the [build] context are global and are applied to 
# all contexts unless otherwise overridden by more specific contexts.
[build]
  # Directory to change to before starting a build.
  # This is where we will look for package.json/.nvmrc/etc.
  # If not set, defaults to the root directory.
  base = "project/"

  # Directory that contains the deploy-ready HTML files and 
  # assets generated by the build. This is relative to the base
  # directory if one has been set, or the root directory if 
  # a base has not been set. This sample publishes the directory 
  # located at the absolute path "root/project/build-output"
  
  publish = "build-output/"

  # Default build command.
  command = "echo 'default context'"
```

### Build functions
> To add a serverless function to your project, create a JavaScript file in your configured functions directory. The file can be stored directly under the functions directory or in a subdirectory dedicated to the function. The function endpoint is determined by its filename or the name of its dedicated parent directory. For example, 

- my_functions/hello.js
- my_functions/hello/hello.js
- my_functions/hello/index.js

are can be called on /.netlify/functions/hello endpoint.

> For a background function, the function file name must end with -background, or the sub-directory that contains the background function file must end with -background. For example, 

- my_functions/hello-background.js
- my_functions/hello-background/hello-background.js
- my_functions/hello-background/index.js

#### Function format
> Each JavaScript file to be deployed as a synchronous function must export a handler method with the following general syntax:

```js 
exports.handler = async function(event, context) {
    // your server-side functionality
}
```

> Netlify provides the event and context parameters when the function is invoked. When you call a function’s endpoint, the handler receives an event object similar to the following:

```js
{
  "path": "Path parameter (original URL encoding)",
  "httpMethod": "Incoming request’s method name",
  "headers": {Incoming request headers},
  "queryStringParameters": {Query string parameters},
  "body": "A JSON string of the request payload",
  "isBase64Encoded": "A boolean flag to indicate if the applicable request payload is Base64-encoded"
}
```

> Although Netlify Functions still support callback syntax, async is more versatile. Because async functions return a promise, we recommend returning a response with at least an HTTP status code instead of allowing the function to time out. Using async in your function code doesn’t automatically designate a function as a background function.

```js
exports.handler = async function (event, context) {
  return {
    statusCode: 200,
    body: JSON.stringify({ message: "Hello World" }),
  };
}
```

> Synchronous functions can return a response object that includes the following information:

```json
{
  "isBase64Encoded": true|false,
  "statusCode": httpStatusCode,
  "headers": { "headerName": "headerValue", ... },
  "multiValueHeaders": { "headerName": ["headerValue", "headerValue2", ...], ... },
  "body": "..."
}
```

## Create your first Netlify serverless function
Serverless means that you write server side code and **the third party will run the codes** so that you don't have to care server management, which could be a tedius job. 

### Project folder map
- orange : React, blue : Netlify
<img src="reference/serverless-project-dir.png" width=205 height=183 alt="project folders" />

1. Create a react app and install netlify-cli to deploy react app through serverless function. 

```
npm install -g netlify-cli
```

2. Each Javascript file to export, which will be asynchronous serverless lambda functions, should have a handler method following a pre-defined syntax. File should be in 'functions' folder and file name will be an endpoint in url like below. 

<img src="reference/netlify-url.png" width=569 height=187 alt="netlify serverless url" />

```javascript
// Netlify provides event/context parameters when event handler invoked
exports.handler = async function(event , context) {
    return { 
        statusCode : 200, // Netlify recommends to return http status code in your handler 
        body : JSON.stringify( { message : "Hello Serverless" })
    }
}

```

3. Create a Netlify toml file for configuration. Recommend to install toml support extension as well.

```toml
[build]
command = 'npm run build' // build setting
functions = 'functions' // where Netlify looks up your server side codes
publish = 'build'
```

And add a script in package.json file to execute. Check out below Netlify cli commands. 

```json
 "dev" : "netlify dev"
```

<img src="reference/netlify-cli.png" width=714 height=644 alt="netlify cli command" />

4. Execute your app and access to below url to check if it works. 
```
http://localhost:(PORT)/.netlify/functions/(YOUR_JS_FILE_NAME)
```

## Reference
- [Cloud Run QuickStart - Docker to Serverless](https://youtu.be/3OP-q55hOUI)
- [What is serverless?](https://serverless-stack.com/chapters/what-is-serverless.html)
- [Create your first Netlify serverless function](https://youtu.be/n_KASTN0gUE)
- [Netlify Docs : Functions](https://docs.netlify.com/functions/overview/)
